# 🍯 💻 Handling Deletes with Related Data
In the exercises, you saw that there is an issue deleting employees that have serviceTickets associated with them. How do we solve this problem? There are a number of potential answers to this question, and choosing the correct one depends on the specifics of the use case of the entity you are deleting.

## Option 1: Restrict
It may be that the correct behavior is that deleting an employee with service tickets should simply not be allowed. In that case, you need to catch the error that would result from trying to delete such an employee, and returning a message to the user that the employee cannot be deleted:
``` csharp
app.MapDelete("/employees/{id}", (int id) =>
{
    try
    {
        using NpgsqlConnection connection = new NpgsqlConnection(connectionString);
        connection.Open();
        using NpgsqlCommand command = connection.CreateCommand();
        command.CommandText = @"
        DELETE FROM Employee WHERE Id=@id
    ";
        command.Parameters.AddWithValue("@id", id);
        command.ExecuteNonQuery();
        return Results.NoContent();
    }
    catch (NpgsqlException ex)
    {
        return Results.BadRequest("Employee has associated service tickets and cannot be deleted");
    }
});
```
## Option 2: Cascade Delete Manually
It could be that the app's owner does not care about service tickets of employees that don't work there anymore. If that's the case, it is safe to delete the service tickets that are associated with the employee before deleting the employee:
``` csharp
app.MapDelete("/employees/{id}", (int id) =>
{
    using NpgsqlConnection connection = new NpgsqlConnection(connectionString);
    connection.Open();
    using NpgsqlCommand command = connection.CreateCommand();
    command.CommandText = @"
        DELETE FROM ServiceTicket WHERE EmployeeId = @id;
        DELETE FROM Employee WHERE Id = @id;
    ";
    command.Parameters.AddWithValue("@id", id);
    command.ExecuteNonQuery();
    return Results.NoContent();
});
```
This works fine, but you can imagine that it would have its limitations. For example, if the `ServiceTicket` table itself was a dependency of a third table, we would have to first get all of the `Id`s of the service tickets that we were going to delete, and delete any data that depended on the service tickets we were about to delete. Instead, we can set the database up to do this automatically (this is the behavior you are used to from `json-server` as well)...

## Option 3: Cascade Delete
We can configure the foreign key in the database to automatically delete related data. For this we need to write a SQL script that we run once with `psql` to alter the ServiceTicket table:
``` sql
\c HoneyRaes
ALTER TABLE ServiceTicket DROP CONSTRAINT serviceticket_employeeid_fkey;
ALTER TABLE ServiceTicket ADD CONSTRAINT serviceticket_employeeid_fkey
FOREIGN KEY (EmployeeId) REFERENCES Employee(Id)
ON DELETE CASCADE;
```
Then the endpoint can go back to how it was before we did the manual delete:
``` csharp
app.MapDelete("/employees/{id}", (int id) =>
{
    using NpgsqlConnection connection = new NpgsqlConnection(connectionString);
    connection.Open();
    using NpgsqlCommand command = connection.CreateCommand();
    command.CommandText = @"
        DELETE FROM Employee WHERE Id = @id;
    ";
    command.Parameters.AddWithValue("@id", id);
    command.ExecuteNonQuery();
    return Results.NoContent();
});
```

The name of the constraint `serviceticket_employeeid_fkey` is generated by the database. You can confirm the name of the constraint that you are trying to change by looking at the schema in pgAdmin:
![service ticket constraints](../../assets/pg-admin-constraints.png)

This option will delete all service tickets associated with an employee before deleting that employee. 

## Option 4: ON DELETE SET NULL
It might be that it is fine to preserve the service tickets without the employee that was assigned to them when the employee is deleted. To do that, you need to change the constraint slightly differently:
``` sql
\c HoneyRaes

ALTER TABLE ServiceTicket DROP CONSTRAINT serviceticket_employeeid_fkey;
ALTER TABLE ServiceTicket
ALTER COLUMN EmployeeId DROP NOT NULL;
ALTER TABLE ServiceTicket ADD CONSTRAINT serviceticket_employeeid_fkey
FOREIGN KEY (EmployeeId) REFERENCES Employee(Id)
ON DELETE SET NULL;
```
This script is dropping the constraint, then dropping the `NOT NULL` requirement from `EmployeeId` (because now we want to make that nullable on the ServiceTicket table), and finall readding the constraint, but setting `EmployeeId` to `NULL` when an employee is deleted whose id matches the `ServiceTicket`'s `EmployeeId`.

This option will set the `EmployeeId` of all service tickets associated with an employee being deleted to `NULL`.  

## Option 5: Soft Delete
Finally, it's possible that we don't really want to delete the employee at all (after all, their data is still useful to the company after they leave their position). In this case, we should _soft delete_ the employee by adding a boolean column like `IsActive` to the model and table that indicate whether an employee is still active. If we update the `IsActive` property of an employee to `false`, that is an indication to the app that we shouldn't display that employee or assign them to new tickets. 

One major downside of this approach is that you have to remember to filter out inactive employees every time you make a relevant query: 
``` sql
SELECT * FROM Employee WHERE IsActive = true;
```
You have to remember to do this anytime your app only wants to show or use "non-deleted" employees

## Summary
As you can see, there is no "best practice" when it comes to handling deletes with related data. You have to decide what the behavior is that you want you app to exhibit, and use the right method for your use case. Try each of them, and decide which one is the best for this use case. 